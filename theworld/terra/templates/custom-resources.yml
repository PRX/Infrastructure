# theworld/custom-resources.yml
AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: Provides services to be used as CloudFormation custom resources

Parameters:
  EnvironmentType: { Type: String }
  EnvironmentTypeAbbreviation: { Type: String }
  RootStackName: { Type: String }
  RootStackId: { Type: String }
  NestedChangeSetScrubbingResourcesState: { Type: String }

Conditions:
  EnableNestedChangeSetScrubbingResources: !Equals [!Ref NestedChangeSetScrubbingResourcesState, Enabled]

Resources:
  NestedChangeSetScrubber: { Type: AWS::SNS::Topic, Condition: EnableNestedChangeSetScrubbingResources }

  AvailabilityZoneSelectorFunction:
    Type: AWS::Serverless::Function
    Properties:
      Architectures: [arm64]
      Description: >-
        Provides information about the availability zones that can and should
        be used for the current region, including a list of zone names, and the
        count of allowed zones
      Handler: index.lambda_handler
      InlineCode: |
        import cfnresponse
        import boto3
        import traceback

        ec2 = boto3.client("ec2")

        # All regions should have at least two AZs after accounting for
        # disallowed AZs. If a region would otherwise be left with only a
        # single AZ, all AZs for that region should be disallowed.
        DISALLOWED_AZS = ["use1-az3"]


        def azFilter(az):
            return az["ZoneId"] not in DISALLOWED_AZS


        def lambda_handler(event, context):
            try:
                print(event)

                if event["RequestType"] == "Create" or event["RequestType"] == "Update":
                    azs = ec2.describe_availability_zones()["AvailabilityZones"]
                    azs.sort(key=lambda a: a["ZoneName"])
                    allowed = list(filter(azFilter, azs))
                    names = list(map(lambda a: a["ZoneName"], allowed))

                    cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                        "ZoneNames": names + names + names,
                        "Count": len(names)
                    })
                else:
                    cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

            except Exception as e:
                print("Function failed due to exception.")
                print(e)
                traceback.print_exc()
                cfnresponse.send(event, context, cfnresponse.FAILED, {})
      MemorySize: 128
      Policies:
        - Version: "2012-10-17"
          Statement:
            - Action: ec2:DescribeAvailabilityZones
              Effect: Allow
              Resource: "*"
      Runtime: python3.13
      Tags:
        prx:meta:tagging-version: "2021-04-07"
        prx:cloudformation:stack-name: !Ref AWS::StackName
        prx:cloudformation:stack-id: !Ref AWS::StackId
        prx:cloudformation:root-stack-name: !Ref RootStackName
        prx:cloudformation:root-stack-id: !Ref RootStackId
        prx:ops:environment: !Ref EnvironmentType
        prx:dev:application: Infrastructure
      Timeout: 60
  AvailabilityZoneSelectorFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/${AvailabilityZoneSelectorFunction}
      RetentionInDays: 14
      Tags:
        - { Key: prx:meta:tagging-version, Value: "2021-04-07" }
        - { Key: prx:cloudformation:stack-name, Value: !Ref AWS::StackName }
        - { Key: prx:cloudformation:stack-id, Value: !Ref AWS::StackId }
        - { Key: prx:cloudformation:root-stack-name, Value: !Ref RootStackName }
        - { Key: prx:cloudformation:root-stack-id, Value: !Ref RootStackId }
        - { Key: prx:ops:environment, Value: !Ref EnvironmentType }
        - { Key: prx:dev:application, Value: Infrastructure }
  AvailabilityZoneSelectorFunctionErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ERROR [Infrastructure] AZ Selector <${EnvironmentTypeAbbreviation}> FUNCTION ERRORS (${RootStackName})
      AlarmDescription: !Sub |-
        ${EnvironmentType} stack custom resource function for selecting
        availability zones is failing. This could mean that a stack update is
        stalled, waiting for an HTTP callback from the function.

        Be careful rolling back the stack; if the function fails again during
        rollback it may become even more stuck. Making the callback request
        manually may be possible, by looking at the function logs.
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref AvailabilityZoneSelectorFunction
      EvaluationPeriods: 1
      MetricName: Errors
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Tags:
        - { Key: prx:meta:tagging-version, Value: "2021-04-07" }
        - { Key: prx:cloudformation:stack-name, Value: !Ref AWS::StackName }
        - { Key: prx:cloudformation:stack-id, Value: !Ref AWS::StackId }
        - { Key: prx:cloudformation:root-stack-name, Value: !Ref RootStackName }
        - { Key: prx:cloudformation:root-stack-id, Value: !Ref RootStackId }
        - { Key: prx:ops:environment, Value: !Ref EnvironmentType }
        - { Key: prx:dev:application, Value: Infrastructure }
      Threshold: 0
      TreatMissingData: notBreaching

  EchoFunction:
    Type: AWS::Serverless::Function
    Properties:
      Architectures: [arm64]
      Description: >-
        Returns any resource properties as outputs. This can be useful when a
        derived value needs to be used several times within a template, but is
        not available via Fn::Ref or Fn::GetAtt from any other resource.
      Handler: index.lambda_handler
      InlineCode: |
        import cfnresponse
        import traceback


        def lambda_handler(event, context):
            try:
                print(event)

                props = event["ResourceProperties"]
                props.pop("ServiceToken", None)
                cfnresponse.send(event, context, cfnresponse.SUCCESS, props)

            except Exception as e:
                print("Function failed due to exception.")
                print(e)
                traceback.print_exc()
                cfnresponse.send(event, context, cfnresponse.FAILED, {})
      MemorySize: 128
      Runtime: python3.13
      Tags:
        prx:meta:tagging-version: "2021-04-07"
        prx:cloudformation:stack-name: !Ref AWS::StackName
        prx:cloudformation:stack-id: !Ref AWS::StackId
        prx:cloudformation:root-stack-name: !Ref RootStackName
        prx:cloudformation:root-stack-id: !Ref RootStackId
        prx:ops:environment: !Ref EnvironmentType
        prx:dev:application: Infrastructure
      Timeout: 4
  EchoFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/${EchoFunction}
      RetentionInDays: 14
      Tags:
        - { Key: prx:meta:tagging-version, Value: "2021-04-07" }
        - { Key: prx:cloudformation:stack-name, Value: !Ref AWS::StackName }
        - { Key: prx:cloudformation:stack-id, Value: !Ref AWS::StackId }
        - { Key: prx:cloudformation:root-stack-name, Value: !Ref RootStackName }
        - { Key: prx:cloudformation:root-stack-id, Value: !Ref RootStackId }
        - { Key: prx:ops:environment, Value: !Ref EnvironmentType }
        - { Key: prx:dev:application, Value: Infrastructure }
  EchoFunctionErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ERROR [Infrastructure] Echo <${EnvironmentTypeAbbreviation}> FUNCTION ERRORS (${RootStackName})
      AlarmDescription: !Sub |-
        ${EnvironmentType} stack custom resource echo function is failing. This
        could mean that a stack update is stalled, waiting for an HTTP callback
        from the function.

        Be careful rolling back the stack; if the function fails again during
        rollback it may become even more stuck. Making the callback request
        manually may be possible, by looking at the function logs.
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref EchoFunction
      EvaluationPeriods: 1
      MetricName: Errors
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Tags:
        - { Key: prx:meta:tagging-version, Value: "2021-04-07" }
        - { Key: prx:cloudformation:stack-name, Value: !Ref AWS::StackName }
        - { Key: prx:cloudformation:stack-id, Value: !Ref AWS::StackId }
        - { Key: prx:cloudformation:root-stack-name, Value: !Ref RootStackName }
        - { Key: prx:cloudformation:root-stack-id, Value: !Ref RootStackId }
        - { Key: prx:ops:environment, Value: !Ref EnvironmentType }
        - { Key: prx:dev:application, Value: Infrastructure }
      Threshold: 0
      TreatMissingData: notBreaching

  Ec2ResourceTaggerFunction:
    Type: AWS::Serverless::Function
    Properties:
      Architectures: [arm64]
      Description: >-
        Manages resource tags for EC2 resources, primarily to allow tagging of
        resources like VPC Endpoints, for which CloudFormation doesn't support
        tagging natively.
      Handler: index.handler
      InlineCode: |
        const response = require('cfn-response');
        const { ConfiguredRetryStrategy } = require('@aws-sdk/util-retry');
        const {
          EC2Client,
          CreateTagsCommand,
          DeleteTagsCommand,
        } = require('@aws-sdk/client-ec2');

        const ec2 = new EC2Client({
          apiVersion: '2016-11-15',
          retryStrategy: new ConfiguredRetryStrategy(6, 1100),
        });

        exports.handler = async (event, context) => {
          console.log(event);

          try {
            const tags = event.ResourceProperties.Tags;
            const id = event.ResourceProperties.ResourceId;

            if (!tags || !tags.length || !id) {
              console.error('ResourceId and Tags properties must be defined');
              await response.send(event, context, response.FAILED, {});
            }

            if (event.RequestType === 'Create') {
              // Create all tags on the custom resource
              await ec2.send(
                new CreateTagsCommand({
                  Resources: [id],
                  Tags: tags,
                }),
              );
            } else if (event.RequestType === 'Update') {
              // Remove tags that were present in the old resource properties, but are
              // no longer present
              const previousTags = event.OldResourceProperties.Tags;
              const currentTagKeys = tags.map((t) => t.Key);

              const staleTags = previousTags.filter(
                (p) => !currentTagKeys.includes(p.Key),
              );

              if (staleTags.length) {
                await ec2.send(
                  new DeleteTagsCommand({
                    Resources: [id],
                    Tags: staleTags,
                  }),
                );
              }

              // Create/update all values present in the current resource properties
              await ec2.send(
                new CreateTagsCommand({
                  Resources: [id],
                  Tags: tags,
                }),
              );
            } else if (event.RequestType === 'Delete') {
              // Remove all tags on the custom resource
              await ec2.send(
                new DeleteTagsCommand({
                  Resources: [id],
                  Tags: tags,
                }),
              );
            }

            await response.send(event, context, response.SUCCESS, {});
          } catch (error) {
            console.error(error);
            await response.send(event, context, response.FAILED, {});
          }
        };
      MemorySize: 128
      Policies:
        - Statement:
            - Action:
                - ec2:CreateTags
                - ec2:DeleteTags
              Effect: Allow
              Resource: "*"
          Version: "2012-10-17"
      Runtime: nodejs20.x
      Tags:
        prx:meta:tagging-version: "2021-04-07"
        prx:cloudformation:stack-name: !Ref AWS::StackName
        prx:cloudformation:stack-id: !Ref AWS::StackId
        prx:cloudformation:root-stack-name: !Ref RootStackName
        prx:cloudformation:root-stack-id: !Ref RootStackId
        prx:ops:environment: !Ref EnvironmentType
        prx:dev:application: Infrastructure
      Timeout: 60
  Ec2ResourceTaggerFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/${Ec2ResourceTaggerFunction}
      RetentionInDays: 14
      Tags:
        - { Key: prx:meta:tagging-version, Value: "2021-04-07" }
        - { Key: prx:cloudformation:stack-name, Value: !Ref AWS::StackName }
        - { Key: prx:cloudformation:stack-id, Value: !Ref AWS::StackId }
        - { Key: prx:cloudformation:root-stack-name, Value: !Ref RootStackName }
        - { Key: prx:cloudformation:root-stack-id, Value: !Ref RootStackId }
        - { Key: prx:ops:environment, Value: !Ref EnvironmentType }
        - { Key: prx:dev:application, Value: Infrastructure }
  Ec2ResourceTaggerFunctionErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ERROR [Infrastructure] EC2 Tagger <${EnvironmentTypeAbbreviation}> FUNCTION ERRORS (${RootStackName})
      AlarmDescription: !Sub |-
        ${EnvironmentType} stack custom resource function for tagging
        EC2 resources is failing. This could mean that a stack update is
        stalled, waiting for an HTTP callback from the function.

        Be careful rolling back the stack; if the function fails again during
        rollback it may become even more stuck. Making the callback request
        manually may be possible, by looking at the function logs.
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref Ec2ResourceTaggerFunction
      EvaluationPeriods: 1
      MetricName: Errors
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Tags:
        - { Key: prx:meta:tagging-version, Value: "2021-04-07" }
        - { Key: prx:cloudformation:stack-name, Value: !Ref AWS::StackName }
        - { Key: prx:cloudformation:stack-id, Value: !Ref AWS::StackId }
        - { Key: prx:cloudformation:root-stack-name, Value: !Ref RootStackName }
        - { Key: prx:cloudformation:root-stack-id, Value: !Ref RootStackId }
        - { Key: prx:ops:environment, Value: !Ref EnvironmentType }
        - { Key: prx:dev:application, Value: Infrastructure }
      Threshold: 0
      TreatMissingData: notBreaching

Outputs:
  AvailabilityZoneSelectorServiceToken:
    Description: Service token for the availability zone selector
    Value: !GetAtt AvailabilityZoneSelectorFunction.Arn
  EchoServiceToken:
    Description: Service token for echo
    Value: !GetAtt EchoFunction.Arn
  Ec2ResourceTaggerServiceToken:
    Description: Service token for EC2 Resource tagger
    Value: !GetAtt Ec2ResourceTaggerFunction.Arn
