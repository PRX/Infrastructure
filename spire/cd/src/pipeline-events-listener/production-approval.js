/**
 * This Lambda receives messages generated by a CodePipeline manual approval
 * action, via SNS. It sends a Slack message with information about the
 * pending approval along with actions (buttons) to take from within Slack
 * to approve or reject the release.
 */

/**
 * @typedef { import('aws-lambda').SNSEvent } SNSEvent
 * @typedef { import('@slack/web-api').ChatPostMessageArguments } ChatPostMessageArguments
 * @typedef { import('@slack/web-api').MessageAttachment } MessageAttachment
 * @typedef {import('@aws-sdk/client-codepipeline').PutApprovalResultInput} PutApprovalResultInput
 * @typedef {import('@aws-sdk/client-codepipeline').ApprovalResult} ApprovalResult
 */

const { SNS } = require('@aws-sdk/client-sns');
const { CodePipeline } = require('@aws-sdk/client-codepipeline');
const regions = require('./etc/regions');
const urls = require('./etc/urls');
const pipelineNames = require('./etc/pipeline-names');
const deltas = require('./deltas/deltas');
const { emoji } = require('./etc/execution-emoji');

const sns = new SNS({
  apiVersion: '2010-03-31',
  region: process.env.SLACK_MESSAGE_RELAY_TOPIC_ARN.split(':')[3],
});
const codepipeline = new CodePipeline({ apiVersion: '2015-07-09' });

/**
 * Constructs a Slack message payload with information about stack parameter
 * changes, and interactive buttons to approve or reject a deploy. If there are
 * no meaningful changes, the deploy is automatically rejected and the message
 * does not include the buttons.
 * @param {CodePipelineApprovalNotification} approvalNotification
 * @returns {Promise<ChatPostMessageArguments>}
 */
async function buildMessage(approvalNotification) {
  const { approval } = approvalNotification;

  /** @type {CodePipelineApprovalCustomData} */
  const customData = JSON.parse(approval.customData);
  const { StackName, ChangeSetName, AccountId, PipelineExecutionId } =
    customData;

  // A bunch of values that will be required to fulfill the action are stuffed
  // into the actions' values as JSON. This object should match the parameters
  // for codepipeline.putApprovalResult().
  /** @type {PutApprovalResultInput} */
  const approvalParams = {
    pipelineName: approval.pipelineName,
    stageName: approval.stageName,
    actionName: approval.actionName,
    token: approval.token,
    result: {
      // @ts-ignore
      status: '',
      summary: '',
    },
  };

  // The summary gets overridden before the approval result is sent, so this
  // is just a convenient place to pass some extra values, albeit a bit
  // hacky
  const summaryData = `${approvalNotification.region},${AccountId}`;

  // These get Object.assigned below to the approvalParams
  /** @type {ApprovalResult} */
  const approvedResult = { status: 'Approved', summary: summaryData };
  /** @type {ApprovalResult} */
  const rejectedResult = { status: 'Rejected', summary: summaryData };

  const region = process.env.AWS_REGION;
  const pipeline = approval.pipelineName;
  const execId = PipelineExecutionId;

  const regionNickname = regions(region);
  const pipelineNickname = pipelineNames(pipeline);
  const url = urls.executionConsoleUrl(region, pipeline, execId);
  const icon = emoji(execId);
  const header = [
    `*<${url}|${regionNickname} Â» ${pipelineNickname}>*`,
    `*Execution ID:* \`${execId}\` ${icon}`,
  ].join('\n');

  const report = await deltas.report(StackName, ChangeSetName);

  // If the change set has no meaningful parameter deltas it is automatically
  // rejected
  if (!report.allowedDeltaCount) {
    await codepipeline.putApprovalResult({
      pipelineName: approval.pipelineName,
      stageName: approval.stageName,
      actionName: approval.actionName,
      token: approval.token,
      result: {
        status: 'Rejected',
        summary: 'Automatically rejected no op',
      },
    });
  }

  // The DevOps Slack app handles the button actions from this message, and is
  // designed to rewrite parts of the message, so it expects a specific message
  // payload structure. If this message changes, the reject/approve/annotate/etc
  // handlers may need to be updated as well.
  //
  // The standard third element (index=2), the actions block with the buttons,
  // is added below, since it's only added if necessary.
  /** @type {MessageAttachment[]} */
  const attachments = [
    {
      color: '#0a4a74',
      fallback: `${regionNickname} ${pipelineNickname} Approve the production change set deltas`,
      blocks: [],
    },
  ];

  // Always include the header and the status
  attachments[0].blocks.push(
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: header,
      },
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text:
          report.allowedDeltaCount > 0
            ? 'Production stack change set has been created, and needs approval.'
            : 'Production stack change set has been automatically rejected.',
      },
    },
  );

  // When the change set include meaningful deltas, include the buttons,
  // otherwise skip it
  if (report.allowedDeltaCount > 0) {
    attachments[0].blocks.push({
      type: 'actions',
      elements: [
        {
          type: 'button',
          text: {
            type: 'plain_text',
            text: 'Approve',
            emoji: true,
          },
          style: 'primary',
          value: JSON.stringify(
            Object.assign(approvalParams, { result: approvedResult }),
          ),
          action_id: 'codepipeline-approval_approve-deploy',
          confirm: {
            title: {
              type: 'plain_text',
              text: 'Production Deploy Approval',
            },
            text: {
              type: 'mrkdwn',
              text: 'Are you sure you want to approve this CloudFormation change set for the production stack? Approval will trigger an immediate update to the production stack!',
            },
            confirm: {
              type: 'plain_text',
              text: 'Approve',
            },
            deny: {
              type: 'plain_text',
              text: 'Cancel',
            },
          },
        },
        {
          type: 'button',
          text: {
            type: 'plain_text',
            text: 'Approve with notes',
            emoji: true,
          },
          value: JSON.stringify(
            Object.assign(approvalParams, { result: approvedResult }),
          ),
          action_id: 'codepipeline-approval_annotate-deploy',
        },
        {
          type: 'button',
          text: {
            type: 'plain_text',
            text: 'Reject',
            emoji: true,
          },
          style: 'danger',
          value: JSON.stringify(
            Object.assign(approvalParams, { result: rejectedResult }),
          ),
          action_id: 'codepipeline-approval_reject-deploy',
        },
      ],
    });
  }

  // Always include the other information
  attachments[0].blocks.push(
    {
      type: 'divider',
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: report.text,
      },
    },
    {
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: `${report.hiddenDeltaCount} deltas were hidden. ${report.rawDeltaCount} parameters were unchanged or ignored.`,
        },
      ],
    },
  );

  return {
    username: 'AWS CodePipeline',
    icon_emoji: ':ops-codepipeline:',
    channel: `#ops-deploys-${approvalNotification.region}`,
    attachments,
  };
}

/**
 * Publishes a Slack message to the relay SNS topic with information about a
 * pending CodePipeline deploy action, with interactive buttons to approve or
 * reject the deploy.
 * @param {SNSEvent} event
 * @returns {Promise<void>}
 */
exports.handler = async (event) => {
  console.log(JSON.stringify(event));

  /** @type {CodePipelineApprovalNotification} */
  const approvalNotification = JSON.parse(event.Records[0].Sns.Message);

  const slackMessage = await buildMessage(approvalNotification);

  await sns.publish({
    TopicArn: process.env.SLACK_MESSAGE_RELAY_TOPIC_ARN,
    Message: JSON.stringify(slackMessage),
  });
};
